# Snapshot Comparison - Quick Reference

## What Gets Cached Per Snapshot?

Every time you run `analyze_repository()`, a new snapshot is created with:

| Data Type | What's Stored | Use Case |
|-----------|---------------|----------|
| **Patterns** | Detected architectural patterns (Layered, MVC, Hexagonal) with confidence scores | Track pattern evolution |
| **Coupling** | Average coupling, high coupling files, circular dependencies | Monitor code quality |
| **Dependencies** | File-level import relationships, total count | Track dependency growth |
| **Architecture Text** | Macro/Meso/Micro explanations generated by LLM | Compare architectural descriptions |
| **Metrics** | Total files, total deps, avg coupling, cycle count | Quantitative comparison |

## Quick Commands

### 1. List All Snapshots
```bash
curl http://localhost:8000/repository/{repo_id}/snapshots
```

### 2. Compare Two Snapshots
```bash
curl http://localhost:8000/repository/{repo_id}/compare-snapshots/{snapshot1_id}/{snapshot2_id}
```

### 3. Python Test Script
```bash
cd backend
python test_snapshot_comparison.py
```

## What You Get in Comparison

### âœ… Included in Response

1. **Snapshot Details** (both snapshots)
   - Files count
   - Dependencies count
   - Average coupling
   - Circular dependencies count
   - Detected patterns
   - Architecture explanation (cached text)

2. **Changes**
   - Files added/removed
   - Dependency delta
   - Coupling delta
   - Cycle delta
   - Pattern changes (newly detected, removed, confidence changes)
   - High coupling file count changes

3. **Risk Assessment**
   - Risk level: low/medium/high
   - Specific risk areas identified
   - Human-readable summary

## Example Output

```json
{
  "changes": {
    "file_delta": +5,
    "dependency_delta": +15,
    "coupling_delta": +0.4,
    "cycle_delta": +2,
    "pattern_changes": {
      "mvc": "newly_detected"
    }
  },
  "risk_assessment": {
    "risk_level": "medium",
    "risk_areas": [
      "Coupling increased by 0.4",
      "2 new circular dependencies"
    ]
  },
  "summary": "Added 5 files; Coupling increased significantly (+0.4); 2 new circular dependencies"
}
```

## Common Use Cases

### 1. Before/After Refactoring
```python
# Analyze before refactoring
POST /analyze {"repo_url": "..."}
# Note snapshot_id_1

# Make changes, then analyze again
POST /analyze {"repo_url": "..."}
# Note snapshot_id_2

# Compare
GET /repository/{repo_id}/compare-snapshots/{snapshot_id_1}/{snapshot_id_2}
```

### 2. Track Weekly Progress
```bash
# Run analysis every week
# Compare latest snapshot with previous week
# Monitor coupling trends, dependency growth
```

### 3. Feature Branch Impact
```bash
# Analyze main branch -> snapshot_main
# Analyze feature branch -> snapshot_feature
# Compare to see impact of feature
```

## Performance Notes

- âš¡ **Fast**: Comparison uses cached data (no re-analysis)
- ðŸ’¾ **Storage**: ~10KB per snapshot (JSON data)
- ðŸ”„ **Scalability**: Handles 100+ snapshots efficiently
- ðŸ“Š **History**: All snapshots preserved (never deleted)

## Troubleshooting

### "Snapshots not found"
- Verify snapshot IDs exist: `GET /repository/{repo_id}/snapshots`
- Use full snapshot UUID (not shortened version)

### "Architecture not cached"
- Normal for older snapshots created before this feature
- Re-analyze repository to create new snapshot with cached data

### Empty comparison results
- Ensure both snapshots belong to same repository
- Check that analysis completed successfully for both

## Integration with Frontend

The comparison data is ready for visualization:
- Timeline view of architecture evolution
- Coupling trend charts
- Dependency growth graphs
- Pattern detection history

## Next Steps

1. Run `test_snapshot_comparison.py` to verify setup
2. Analyze a repository twice to create 2 snapshots
3. Compare them to see the system in action
4. Integrate comparison endpoint into your workflow

For detailed documentation, see [SNAPSHOT_COMPARISON.md](SNAPSHOT_COMPARISON.md)
